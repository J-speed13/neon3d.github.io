<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Velocity 3D - Auto Shoot</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none; /* Prevent browser handling of gestures */
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            z-index: 10;
            pointer-events: none;
            width: calc(100% - 40px);
        }

        #score-board {
            font-size: 24px;
            font-weight: bold;
        }
        
        #level-board {
            font-size: 18px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            margin-top: 5px;
        }

        #speed-board {
            font-size: 16px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin-top: 5px;
        }

        /* Health Bar Styles */
        #health-container {
            position: absolute;
            top: 0;
            right: 0;
            width: 200px;
            height: 20px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            background: rgba(0, 0, 0, 0.5);
            transform: skewX(-20deg);
        }
        
        @media (max-width: 600px) {
            #health-container {
                width: 120px;
            }
            #score-board {
                font-size: 18px;
            }
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
            transition: width 0.2s, background-color 0.2s;
        }

        #health-label {
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 14px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            text-align: right;
            width: 200px;
        }
        
        #level-message {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff, 0 0 40px #ffff00;
            font-weight: 900;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 15;
            text-align: center;
            width: 100%;
        }
        
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 15;
            background: rgba(0,0,0,0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            pointer-events: auto;
        }

        #menu-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            width: 80%;
            max-width: 500px;
            box-sizing: border-box;
        }

        h1 {
            color: #ff3333;
            font-size: 40px;
            text-shadow: 0 0 20px #ff0000;
            margin: 0 0 10px 0;
            letter-spacing: 2px;
            word-wrap: break-word;
        }
        
        h2 {
            color: #00ffff;
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        button {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            box-shadow: 0 0 15px #00ffff;
            transition: 0.2s;
            text-transform: uppercase;
            max-width: 100%;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="score-board">SCORE: 0</div>
        <div id="level-board">LEVEL: 1</div>
        <div id="speed-board">SPEED: 100%</div>
        
        <div id="health-label">HULL INTEGRITY</div>
        <div id="health-container">
            <div id="health-fill"></div>
        </div>
    </div>
    
    <div id="level-message">LEVEL UP!</div>
    <button id="mute-btn" onclick="toggleMute()">MUTE MUSIC</button>

    <div id="menu-screen">
        <h1 id="menu-title">NEON VELOCITY</h1>
        <h2 id="menu-subtitle">SPACE/CLICK TO SHOOT.<br>(AUTO-FIRE ON MOBILE)<br>AVOID RED PILLARS.<br>LEVEL UP EVERY 50 POINTS.<br><br>MOUSE OR TOUCH TO MOVE</h2>
        <button id="start-btn" onclick="startGame()">INITIATE SYSTEM</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let snareBuffer;
        let isMuted = false;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (!snareBuffer) {
                const bufferSize = audioCtx.sampleRate;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                snareBuffer = buffer;
            }
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('mute-btn');
            btn.innerText = isMuted ? "UNMUTE MUSIC" : "MUTE MUSIC";
            if (isMuted) {
                MusicSystem.stop();
            } else if (isGameRunning) {
                MusicSystem.start();
            }
        }

        // --- MUSIC GENERATOR ---
        const MusicSystem = {
            isPlaying: false,
            lookahead: 25.0,
            scheduleAheadTime: 0.1,
            nextNoteTime: 0.0,
            current16thNote: 0,
            timerID: null,
            
            bassLine: [
                55.00, 55.00, 55.00, 55.00, // A1
                43.65, 43.65, 43.65, 43.65, // F1
                65.41, 65.41, 65.41, 65.41, // C2
                49.00, 49.00, 49.00, 49.00  // G1
            ],
            
            leadLine: [
                440.00, 523.25, 659.25, 880.00, 
                349.23, 440.00, 523.25, 698.46,
                523.25, 659.25, 783.99, 1046.50,
                392.00, 493.88, 587.33, 783.99
            ],

            start: function() {
                if (this.isPlaying || isMuted) return;
                if (!audioCtx) initAudio();
                this.isPlaying = true;
                this.current16thNote = 0;
                this.nextNoteTime = audioCtx.currentTime + 0.1;
                this.scheduler();
            },

            stop: function() {
                this.isPlaying = false;
                clearTimeout(this.timerID);
            },

            scheduler: function() {
                if (!this.isPlaying) return;
                while (this.nextNoteTime < audioCtx.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.current16thNote, this.nextNoteTime);
                    this.nextNote();
                }
                this.timerID = setTimeout(() => this.scheduler(), this.lookahead);
            },

            nextNote: function() {
                const secondsPerBeat = 60.0 / 110;
                this.nextNoteTime += 0.25 * secondsPerBeat;
                this.current16thNote++;
                if (this.current16thNote === 16) this.current16thNote = 0;
            },

            scheduleNote: function(beatNumber, time) {
                if (beatNumber % 2 === 0) {
                    this.playOsc(this.bassLine[beatNumber], time, 0.1, 'sawtooth', 0.15);
                }
                let vol = (beatNumber % 4 === 0) ? 0.08 : 0.04;
                this.playOsc(this.leadLine[beatNumber], time, 0.1, 'square', vol);
                
                if (beatNumber % 4 === 0) this.playKick(time);
                if (beatNumber === 4 || beatNumber === 12) this.playSnare(time);
            },
            
            playOsc: function(freq, time, dur, type, vol) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter(); 
                
                osc.type = type;
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
                
                osc.start(time);
                osc.stop(time + dur);
            },
            
            playKick: function(time) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(time);
                osc.stop(time + 0.5);
            },
            
            playSnare: function(time) {
                if (!snareBuffer) return;
                const noise = audioCtx.createBufferSource();
                noise.buffer = snareBuffer;
                const noiseGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800;

                noiseGain.gain.setValueAtTime(0.15, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.start(time);
            }
        };

        function playSound(type) {
            if (!audioCtx || isMuted) return;
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'explosion') {
                // Noise burst for explosion
                if (snareBuffer) {
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = snareBuffer;
                    const noiseGain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;
                    
                    noiseGain.gain.setValueAtTime(0.3, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    
                    noise.connect(filter);
                    filter.connect(noiseGain);
                    noiseGain.connect(audioCtx.destination);
                    noise.start(now);
                    
                    // Don't need osc for this one
                    osc.disconnect();
                    gainNode.disconnect();
                    return; 
                }
            } else if (type === 'heal') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0.001, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'crash') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'gameover') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 1.0);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            } else if (type === 'levelup') {
                const freqs = [523.25, 659.25, 783.99, 1046.50];
                for(let i=0; i<4; i++) {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'square';
                    o.frequency.value = freqs[i];
                    g.gain.setValueAtTime(0.1, now + i*0.1);
                    g.gain.exponentialRampToValueAtTime(0.001, now + i*0.1 + 0.4);
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.start(now + i*0.1);
                    o.stop(now + i*0.1 + 0.4);
                }
            }
        }


        // --- GAME VARIABLES ---
        let scene, camera, renderer;
        let player;
        let obstacles = [];
        let bullets = [];
        let debris = [];
        let powerups = [];
        let healthOrbs = [];
        let particles = [];
        let gridHelper;
        
        let score = 0;
        let level = 1;
        let gameSpeed = 0.5;
        let isGameRunning = false;
        
        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let lastAutoShootTime = 0;
        
        let maxHealth = 100;
        let currentHealth = 100;
        let isInvincible = false;
        
        const PALETTES = [
            { bg: 0x050510, grid: 0x9900ff, fog: 0x050510 },
            { bg: 0x001010, grid: 0x00ffff, fog: 0x001010 },
            { bg: 0x001000, grid: 0x00ff00, fog: 0x001000 },
            { bg: 0x150500, grid: 0xff5500, fog: 0x150500 },
            { bg: 0x100010, grid: 0xff00ff, fog: 0x100010 },
            { bg: 0x000000, grid: 0xffffff, fog: 0x000000 }
        ];

        const COLOR_PLAYER = 0x00ffff;
        const COLOR_OBSTACLE = 0xff0055;
        const COLOR_POWERUP = 0xffff00;
        const COLOR_HEALTH = 0x00ff00;
        const COLOR_BULLET = 0x00ffff;

        // --- INIT THREE.JS ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(PALETTES[0].bg);
            scene.fog = new THREE.FogExp2(PALETTES[0].fog, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 2); 
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(0, 10, 5);
            scene.add(dirLight);

            gridHelper = new THREE.GridHelper(200, 50, PALETTES[0].grid, PALETTES[0].grid);
            gridHelper.position.y = -1;
            gridHelper.position.z = -50;
            scene.add(gridHelper);

            const geometry = new THREE.ConeGeometry(0.5, 1.5, 4);
            const material = new THREE.MeshStandardMaterial({ 
                color: COLOR_PLAYER,
                emissive: COLOR_PLAYER,
                emissiveIntensity: 0.5,
                roughness: 0.1
            });
            player = new THREE.Mesh(geometry, material);
            player.rotation.x = -Math.PI / 2;
            player.rotation.y = Math.PI / 4;
            scene.add(player);

            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 600;
            const posArray = new Float32Array(particleCount * 3);
            for(let i = 0; i < particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particleMat = new THREE.PointsMaterial({
                size: 0.15,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const starMesh = new THREE.Points(particleGeo, particleMat);
            scene.add(starMesh);
            particles.push(starMesh);

            // CONTROLS
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('touchmove', onDocumentTouchMove, { passive: false });
            window.addEventListener('resize', onWindowResize, false);
            
            // SHOOTING CONTROLS
            window.addEventListener('click', shoot);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') shoot();
            });
            
            animate();
        }

        // --- GAME LOGIC ---

        function startGame() {
            initAudio(); 
            MusicSystem.start();
            document.getElementById('menu-screen').style.display = 'none';
            
            isGameRunning = true;
            score = 0;
            level = 1;
            gameSpeed = 0.5;
            currentHealth = maxHealth;
            
            updateHealthUI();
            updateLevelUI(false);
            applyTheme(0);
            
            player.position.x = 0;
            player.visible = true;
            player.material.emissive.setHex(COLOR_PLAYER);
            
            obstacles.forEach(o => scene.remove(o));
            obstacles = [];
            powerups.forEach(p => scene.remove(p));
            powerups = [];
            healthOrbs.forEach(h => scene.remove(h));
            healthOrbs = [];
            bullets.forEach(b => scene.remove(b));
            bullets = [];
            debris.forEach(d => scene.remove(d));
            debris = [];

            spawnLoop();
        }

        function shoot() {
            if (!isGameRunning) return;
            
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: COLOR_BULLET });
            const bullet = new THREE.Mesh(geometry, material);
            
            // Start at player position
            bullet.position.copy(player.position);
            bullet.position.z -= 1.0; 
            
            scene.add(bullet);
            bullets.push(bullet);
            playSound('shoot');
        }

        function createExplosion(position) {
            playSound('explosion');
            
            // Create 8 small cubes as debris
            for (let i = 0; i < 8; i++) {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: COLOR_OBSTACLE });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.copy(position);
                
                // Random velocity vector
                mesh.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                scene.add(mesh);
                debris.push(mesh);
            }
        }

        function spawnLoop() {
            if (!isGameRunning) return;

            const randomVal = Math.random();
            if (randomVal > 0.9) {
                spawnHealthOrb();
            } else if (randomVal > 0.8) {
                spawnPowerup();
            } else {
                spawnObstacle();
            }

            let spawnRate = Math.max(300, 900 - (gameSpeed * 500));
            setTimeout(spawnLoop, spawnRate);
        }

        function spawnObstacle() {
            const size = Math.random() * 1.5 + 0.5;
            const geometry = new THREE.BoxGeometry(size, size * 5, size); 
            const material = new THREE.MeshStandardMaterial({ 
                color: COLOR_OBSTACLE,
                emissive: COLOR_OBSTACLE,
                emissiveIntensity: 0.6
            });
            const obj = new THREE.Mesh(geometry, material);
            obj.position.set((Math.random() - 0.5) * 22, 0, -100);
            scene.add(obj);
            obstacles.push(obj);
        }

        function spawnPowerup() {
            const geometry = new THREE.IcosahedronGeometry(0.6, 0);
            const material = new THREE.MeshStandardMaterial({
                color: COLOR_POWERUP,
                emissive: COLOR_POWERUP,
                emissiveIntensity: 0.8
            });
            const obj = new THREE.Mesh(geometry, material);
            obj.position.set((Math.random() - 0.5) * 20, 0.5, -100);
            scene.add(obj);
            powerups.push(obj);
        }

        function spawnHealthOrb() {
            const geometry = new THREE.DodecahedronGeometry(0.6, 0);
            const material = new THREE.MeshStandardMaterial({
                color: COLOR_HEALTH,
                emissive: COLOR_HEALTH,
                emissiveIntensity: 0.8
            });
            const obj = new THREE.Mesh(geometry, material);
            obj.position.set((Math.random() - 0.5) * 20, 0.5, -100);
            scene.add(obj);
            healthOrbs.push(obj);
        }

        function takeDamage() {
            if (isInvincible) return;

            currentHealth -= 34;
            updateHealthUI();
            
            if (currentHealth <= 0) {
                gameOver();
            } else {
                playSound('crash');
                triggerInvincibility();
            }
        }

        function heal() {
            currentHealth += 34;
            if (currentHealth > maxHealth) currentHealth = maxHealth;
            playSound('heal');
            updateHealthUI();
        }

        function triggerInvincibility() {
            isInvincible = true;
            let flickerCount = 0;
            const flickerInterval = setInterval(() => {
                player.visible = !player.visible;
                flickerCount++;
                if (flickerCount > 10) {
                    clearInterval(flickerInterval);
                    player.visible = true;
                    isInvincible = false;
                }
            }, 100);
        }

        function updateHealthUI() {
            const fill = document.getElementById('health-fill');
            const percent = (currentHealth / maxHealth) * 100;
            fill.style.width = percent + '%';
            if (percent > 60) fill.style.backgroundColor = '#00ff00';
            else if (percent > 30) fill.style.backgroundColor = '#ffff00';
            else fill.style.backgroundColor = '#ff0000';
            fill.style.boxShadow = `0 0 15px ${fill.style.backgroundColor}`;
        }
        
        function updateLevelUI(flash = true) {
            document.getElementById('level-board').innerText = "LEVEL: " + level;
            if (flash) {
                const msg = document.getElementById('level-message');
                msg.style.opacity = 1;
                playSound('levelup');
                setTimeout(() => { msg.style.opacity = 0; }, 2000);
            }
        }
        
        function applyTheme(themeIndex) {
            const p = PALETTES[themeIndex % PALETTES.length];
            scene.background.setHex(p.bg);
            scene.fog.color.setHex(p.fog);
            if(gridHelper) {
                 scene.remove(gridHelper);
                 gridHelper = new THREE.GridHelper(200, 50, p.grid, p.grid);
                 gridHelper.position.y = -1;
                 gridHelper.position.z = -50;
                 scene.add(gridHelper);
            }
        }

        function gameOver() {
            isGameRunning = false;
            playSound('gameover');
            MusicSystem.stop();
            const menu = document.getElementById('menu-screen');
            document.getElementById('menu-title').innerText = "SYSTEM FAILURE";
            document.getElementById('menu-subtitle').innerHTML = "HULL INTEGRITY CRITICAL.<br>FINAL SCORE: " + Math.floor(score);
            document.getElementById('start-btn').innerText = "REBOOT SYSTEM";
            menu.style.display = 'block';
            camera.position.x = (Math.random() - 0.5) * 2;
            camera.position.y = (Math.random() - 0.5) * 2 + 2;
        }

        function onDocumentMouseMove(event) {
            if (!isGameRunning) return;
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            updatePlayerPosition(mouseX);
        }

        function onDocumentTouchMove(event) {
            if (!isGameRunning) return;
            event.preventDefault();
            const touch = event.touches[0];
            const touchX = (touch.clientX / window.innerWidth) * 2 - 1;
            updatePlayerPosition(touchX);
        }

        function updatePlayerPosition(normalizedX) {
            const targetX = normalizedX * 9;
            player.position.x += (targetX - player.position.x) * 0.15;
            player.rotation.z = -(targetX - player.position.x) * 0.8;
        }

        function update() {
            if (!isGameRunning) return;
            
            // Auto Shoot for Mobile
            if (isMobile) {
                const now = Date.now();
                if (now - lastAutoShootTime > 300) { // Shoot every 300ms
                    shoot();
                    lastAutoShootTime = now;
                }
            }

            gameSpeed += 0.0003;
            score += 0.1; 

            document.getElementById('score-board').innerText = "SCORE: " + Math.floor(score);
            document.getElementById('speed-board').innerText = "SPEED: " + (gameSpeed * 200).toFixed(0) + " km/h";
            
            const calculatedLevel = Math.floor(score / 50) + 1;
            if (calculatedLevel > level) {
                level = calculatedLevel;
                updateLevelUI(true);
                applyTheme(level - 1);
            }

            // Update Debris (Explosions)
            for (let i = debris.length - 1; i >= 0; i--) {
                let d = debris[i];
                d.position.add(d.userData.velocity);
                d.rotation.x += 0.1;
                d.rotation.y += 0.1;
                d.scale.multiplyScalar(0.9); // Shrink
                
                if (d.scale.x < 0.05) {
                    scene.remove(d);
                    debris.splice(i, 1);
                }
            }

            // Update Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.position.z -= 2.0; // Move fast away from player
                
                let hit = false;
                // Collision with obstacles
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    let obs = obstacles[j];
                    if (checkCollision(b, obs, 2.0)) {
                        createExplosion(obs.position);
                        scene.remove(obs);
                        obstacles.splice(j, 1);
                        hit = true;
                        score += 5; // Bonus for shooting
                        break; 
                    }
                }
                
                if (hit) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                if (b.position.z < -120) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // Update Obstacles (Red)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obj = obstacles[i];
                obj.position.z += gameSpeed;

                if (checkCollision(player, obj, 1.2)) {
                    takeDamage();
                }

                if (obj.position.z > 10) {
                    scene.remove(obj);
                    obstacles.splice(i, 1);
                }
            }

            // Update Powerups (Yellow)
            for (let i = powerups.length - 1; i >= 0; i--) {
                let obj = powerups[i];
                obj.position.z += gameSpeed;
                obj.rotation.x += 0.05;
                obj.rotation.y += 0.05;

                if (checkCollision(player, obj, 1.5)) {
                    playSound('collect');
                    score += 15;
                    scene.remove(obj);
                    powerups.splice(i, 1);
                    continue;
                }
                if (obj.position.z > 10) {
                    scene.remove(obj);
                    powerups.splice(i, 1);
                }
            }

            // Update Health Orbs (Green)
            for (let i = healthOrbs.length - 1; i >= 0; i--) {
                let obj = healthOrbs[i];
                obj.position.z += gameSpeed;
                obj.rotation.z -= 0.05;
                obj.rotation.y -= 0.05;

                if (checkCollision(player, obj, 1.5)) {
                    heal();
                    scene.remove(obj);
                    healthOrbs.splice(i, 1);
                    continue;
                }
                if (obj.position.z > 10) {
                    scene.remove(obj);
                    healthOrbs.splice(i, 1);
                }
            }

            particles[0].rotation.z += 0.002;
            particles[0].position.z += gameSpeed;
            if(particles[0].position.z > 20) particles[0].position.z = -20;
        }

        function checkCollision(obj1, obj2, threshold) {
            let dx = obj1.position.x - obj2.position.x;
            let dz = obj1.position.z - obj2.position.z;
            return Math.sqrt(dx*dx + dz*dz) < threshold;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();

    </script>
</body>
</html>